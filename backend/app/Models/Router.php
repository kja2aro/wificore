<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use App\Traits\HasUuid;
use App\Traits\BelongsToTenant;
use App\Models\Scopes\TenantScope;

class Router extends Model
{
    use HasFactory, HasUuid, BelongsToTenant;

    /**
     * The "booted" method of the model.
     */
    protected static function booted(): void
    {
        static::addGlobalScope(new TenantScope());
    }

    protected $fillable = [
        'tenant_id',
        'name',
        'ip_address',
        'model',
        'os_version',
        'last_seen',
        'port',
        'username',
        'password',
        'location',
        'status',
        'provisioning_stage',
        'interface_assignments',
        'configurations',
        'config_token',
        'vendor',
        'device_type',
        'capabilities',
        'interface_list',
        'reserved_interfaces',
    ];

    protected $hidden = ['password'];

    protected $casts = [
        'id' => 'string',
        'last_seen' => 'datetime',
        'created_at' => 'datetime',
        'updated_at' => 'datetime',
        'deleted_at' => 'datetime',
        'interface_assignments' => 'array',
        'configurations' => 'array',
        'capabilities' => 'array',
        'interface_list' => 'array',
        'reserved_interfaces' => 'array',
    ];
    public function wireguardPeers()
    {
        return $this->hasMany(WireguardPeer::class, 'router_id', 'id');
    }

    public function routerConfigs()
    {
        return $this->hasMany(RouterConfig::class, 'router_id', 'id');
    }

    public function packages()
    {
        return $this->belongsToMany(Package::class, 'package_router')
            ->withTimestamps();
    }

    public function payments()
    {
        return $this->hasMany(Payment::class, 'router_id', 'id');
    }

    public function sessions()
    {
        return $this->hasMany(UserSession::class, 'router_id', 'id');
    }

    /**
     * Get total revenue generated by this router
     */
    public function getTotalRevenue()
    {
        return $this->payments()->where('status', 'completed')->sum('amount');
    }

    /**
     * Get revenue breakdown by package for this router
     */
    public function getRevenueByPackage()
    {
        return $this->payments()
            ->where('status', 'completed')
            ->selectRaw('package_id, SUM(amount) as total_revenue, COUNT(*) as transaction_count')
            ->groupBy('package_id')
            ->with('package:id,name')
            ->get();
    }

    /**
     * Get VPN configuration for this router
     */
    public function vpnConfig()
    {
        return $this->hasOne(RouterVpnConfig::class);
    }

    /**
     * Check if router has VPN configured
     */
    public function hasVpn(): bool
    {
        return $this->vpnConfig !== null;
    }

    /**
     * Check if VPN is connected
     */
    public function isVpnConnected(): bool
    {
        return $this->vpnConfig?->isConnected() ?? false;
    }

    /**
     * Get VPN IP address
     */
    public function getVpnIpAttribute(): ?string
    {
        return $this->vpnConfig?->vpn_ip_address;
    }

    // ========================================
    // NEW: Service Management Relationships
    // ========================================

    /**
     * Get services running on this router
     */
    public function services()
    {
        return $this->hasMany(RouterService::class);
    }

    /**
     * Get access points connected to this router
     */
    public function accessPoints()
    {
        return $this->hasMany(AccessPoint::class);
    }

    // ========================================
    // NEW: Service Management Methods
    // ========================================

    /**
     * Get active services
     */
    public function activeServices()
    {
        return $this->services()->active();
    }

    /**
     * Get service by type
     */
    public function getServiceByType(string $type): ?RouterService
    {
        return $this->services()->where('service_type', $type)->first();
    }

    /**
     * Check if router has a specific service
     */
    public function hasService(string $type): bool
    {
        return $this->services()->where('service_type', $type)->exists();
    }

    /**
     * Check if router has active service of type
     */
    public function hasActiveService(string $type): bool
    {
        return $this->services()
            ->where('service_type', $type)
            ->where('status', RouterService::STATUS_ACTIVE)
            ->exists();
    }

    /**
     * Get online access points
     */
    public function onlineAccessPoints()
    {
        return $this->accessPoints()->online();
    }

    /**
     * Get total active users across all services
     */
    public function getTotalActiveUsers(): int
    {
        return $this->services()->sum('active_users');
    }

    /**
     * Get total active users across all access points
     */
    public function getTotalAPUsers(): int
    {
        return $this->accessPoints()->sum('active_users');
    }

    /**
     * Check if interface is available
     */
    public function isInterfaceAvailable(string $interface): bool
    {
        $reserved = $this->reserved_interfaces ?? [];
        return !isset($reserved[$interface]);
    }

    /**
     * Reserve interface for service
     */
    public function reserveInterface(string $interface, string $serviceType): bool
    {
        $reserved = $this->reserved_interfaces ?? [];
        $reserved[$interface] = $serviceType;
        $this->reserved_interfaces = $reserved;
        return $this->save();
    }

    /**
     * Release interface
     */
    public function releaseInterface(string $interface): bool
    {
        $reserved = $this->reserved_interfaces ?? [];
        unset($reserved[$interface]);
        $this->reserved_interfaces = $reserved;
        return $this->save();
    }

    /**
     * Get available interfaces
     */
    public function getAvailableInterfaces(): array
    {
        $all = $this->interface_list ?? [];
        $reserved = array_keys($this->reserved_interfaces ?? []);
        return array_diff($all, $reserved);
    }
} 
 