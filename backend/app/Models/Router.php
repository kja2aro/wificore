<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use App\Traits\HasUuid;
use App\Traits\BelongsToTenant;
use App\Models\Scopes\TenantScope;
use Illuminate\Support\Facades\Log;

class Router extends Model
{
    use HasFactory, HasUuid;

    protected static function booted(): void
    {
        // No global scope needed for tenant-specific tables
    }

    /**
     * Resolve the model for route model binding.
     * Ensures tenant context is set before querying tenant-specific tables.
     */
    public function resolveRouteBinding($value, $field = null)
    {
        // Get the authenticated user and set tenant context before query
        $user = request()->user();
        
        if ($user && $user->tenant_id) {
            $tenant = Tenant::find($user->tenant_id);
            
            if ($tenant && $tenant->schema_name) {
                $tenantContext = app(\App\Services\TenantContext::class);
                
                // Only set if not already set
                if (!$tenantContext->getTenant()) {
                    $tenantContext->setTenant($tenant);
                    Log::debug('Router route binding: Set tenant context', [
                        'tenant_id' => $tenant->id,
                        'schema_name' => $tenant->schema_name,
                    ]);
                }
            }
        }
        
        return parent::resolveRouteBinding($value, $field);
    }

    protected $fillable = [
        // tenant_id removed for schema isolation
        'name',
        'ip_address',
        'vpn_ip',
        'vpn_status',
        'vpn_enabled',
        'vpn_last_handshake',
        'model',
        'os_version',
        'last_seen',
        'port',
        'username',
        'password',
        'ssh_key',
        'ssh_key_created_at',
        'ssh_key_rotated_at',
        'location',
        'status',
        'provisioning_stage',
        'interface_assignments',
        'configurations',
        'config_token',
        'vendor',
        'device_type',
        'capabilities',
        'interface_list',
        'reserved_interfaces',

        'snmp_enabled',
        'snmp_version',
        'snmp_v3_user',
        'snmp_v3_auth_protocol',
        'snmp_v3_auth_password',
        'snmp_v3_priv_protocol',
        'snmp_v3_priv_password',
        'snmp_trap_enabled',
        'snmp_trap_version',
        'snmp_trap_community',
        'snmp_trap_target',
    ];

    protected $hidden = ['password', 'ssh_key', 'snmp_v3_auth_password', 'snmp_v3_priv_password', 'snmp_trap_community'];

    protected $casts = [
        'id' => 'string',
        'last_seen' => 'datetime',
        'vpn_last_handshake' => 'datetime',
        'vpn_enabled' => 'boolean',
        'ssh_key_created_at' => 'datetime',
        'ssh_key_rotated_at' => 'datetime',
        'created_at' => 'datetime',
        'updated_at' => 'datetime',
        'deleted_at' => 'datetime',
        'interface_assignments' => 'array',
        'configurations' => 'array',
        'capabilities' => 'array',
        'interface_list' => 'array',
        'reserved_interfaces' => 'array',

        'snmp_enabled' => 'boolean',
        'snmp_trap_enabled' => 'boolean',
        'snmp_v3_auth_password' => 'encrypted',
        'snmp_v3_priv_password' => 'encrypted',
        'snmp_trap_community' => 'encrypted',
    ];

    public function wireguardPeers()
    {
        return $this->hasMany(WireguardPeer::class, 'router_id', 'id');
    }

    public function routerConfigs()
    {
        return $this->hasMany(RouterConfig::class, 'router_id', 'id');
    }

    public function packages()
    {
        return $this->belongsToMany(Package::class, 'package_router')
            ->withTimestamps();
    }

    public function payments()
    {
        return $this->hasMany(Payment::class, 'router_id', 'id');
    }

    public function sessions()
    {
        return $this->hasMany(UserSession::class, 'router_id', 'id');
    }

    /**
     * Get total revenue generated by this router
     */
    public function getTotalRevenue()
    {
        return $this->payments()->where('status', 'completed')->sum('amount');
    }

    /**
     * Get revenue breakdown by package for this router
     */
    public function getRevenueByPackage()
    {
        return $this->payments()
            ->where('status', 'completed')
            ->selectRaw('package_id, SUM(amount) as total_revenue, COUNT(*) as transaction_count')
            ->groupBy('package_id')
            ->with('package:id,name')
            ->get();
    }

    /**
     * Get VPN configuration for this router
     */
    public function vpnConfiguration()
    {
        return $this->hasOne(VpnConfiguration::class, 'router_id', 'id');
    }

    /**
     * Check if router has VPN configured
     */
    public function hasVpn(): bool
    {
        return $this->vpnConfiguration !== null || $this->vpn_enabled;
    }

    /**
     * Check if VPN is connected
     */
    public function isVpnConnected(): bool
    {
        if ($this->vpn_status === 'active' && $this->vpn_last_handshake) {
            // Consider connected if handshake within last 3 minutes
            return $this->vpn_last_handshake->diffInMinutes(now()) < 3;
        }
        return false;
    }

    /**
     * Get effective IP address (VPN if available, otherwise regular IP)
     */
    public function getEffectiveIpAttribute(): string
    {
        return $this->vpn_ip ?? $this->ip_address;
    }

    // ========================================
    // NEW: Service Management Relationships
    // ========================================

    /**
     * Get services running on this router
     */
    public function services()
    {
        return $this->hasMany(RouterService::class, 'router_id', 'id');
    }

    /**
     * Get access points connected to this router
     */
    public function accessPoints()
    {
        return $this->hasMany(AccessPoint::class, 'router_id', 'id');
    }

    // ========================================
    // NEW: Service Management Methods
    // ========================================

    /**
     * Get active services
     */
    public function activeServices()
    {
        return $this->services()->active();
    }

    /**
     * Get service by type
     */
    public function getServiceByType(string $type): ?RouterService
    {
        return $this->services()->where('service_type', $type)->first();
    }

    /**
     * Check if router has a specific service
     */
    public function hasService(string $type): bool
    {
        return $this->services()->where('service_type', $type)->exists();
    }

    /**
     * Check if router has active service of type
     */
    public function hasActiveService(string $type): bool
    {
        return $this->services()
            ->where('service_type', $type)
            ->where('status', RouterService::STATUS_ACTIVE)
            ->exists();
    }

    /**
     * Get online access points
     */
    public function onlineAccessPoints()
    {
        return $this->accessPoints()->online();
    }

    /**
     * Get total active users across all services
     */
    public function getTotalActiveUsers(): int
    {
        return $this->services()->sum('active_users');
    }

    /**
     * Get total active users across all access points
     */
    public function getTotalAPUsers(): int
    {
        return $this->accessPoints()->sum('active_users');
    }

    /**
     * Check if interface is available
     */
    public function isInterfaceAvailable(string $interface): bool
    {
        $reserved = $this->reserved_interfaces ?? [];
        return !isset($reserved[$interface]);
    }

    /**
     * Reserve interface for service
     */
    public function reserveInterface(string $interface, string $serviceType): bool
    {
        $reserved = $this->reserved_interfaces ?? [];
        $reserved[$interface] = $serviceType;
        $this->reserved_interfaces = $reserved;
        return $this->save();
    }

    /**
     * Release interface
     */
    public function releaseInterface(string $interface): bool
    {
        $reserved = $this->reserved_interfaces ?? [];
        unset($reserved[$interface]);
        $this->reserved_interfaces = $reserved;
        return $this->save();
    }

    /**
     * Get available interfaces
     */
    public function getAvailableInterfaces(): array
    {
        $all = $this->interface_list ?? [];
        $reserved = array_keys($this->reserved_interfaces ?? []);
        return array_diff($all, $reserved);
    }
}